<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel D&D Party Encounter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #2c3e50;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #start-menu {
            background-color: #34495e;
            padding: 30px;
            border: 4px solid #7f8c8d;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            text-align: center;
        }
        #start-menu h1 {
            color: #f1c40f;
            margin-bottom: 20px;
        }
        #start-menu button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }
        .game-container {
            display: none; /* Hidden by default */
            grid-template-columns: auto 350px; 
            gap: 20px;
            background-color: #34495e;
            padding: 20px;
            border: 4px solid #7f8c8d;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .map-grid {
            display: grid;
            border: 2px solid #7f8c8d;
            position: relative;
        }
        .map-cell {
            width: 30px;
            height: 30px;
            background-color: #95a5a6;
            border: 1px solid #7f8c8d;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .obstacle {
            background-color: #7f8c8d !important;
            color: #34495e;
        }
        .active-character-cell-map { 
            outline: 3px dashed #f1c40f !important; 
            z-index: 5; 
        }
        .party-member, .enemy { 
            width: 26px;
            height: 26px;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            border: 2px solid black;
            transition: left 0.2s ease, top 0.2s ease, box-shadow 0.2s ease; 
            z-index: 10; /* Living characters on top */
            pointer-events: none;
        }
        .party-member.active-sprite { 
            box-shadow: 0 0 8px 4px #f1c40f; 
        }
        .enemy.active-sprite { 
             box-shadow: 0 0 8px 4px #e74c3c; 
        }
        .mage { background-color: #8e44ad; color: white; } 
        .rogue { background-color: #607d8b; color: white; } 
        .goblin-enemy { 
            background-color: #2ecc71; 
            color: white; 
            box-shadow: 0 0 6px 3px rgba(255, 0, 0, 0.5); 
        }
         .boss-goblin-enemy {
            background-color: #1abc9c; 
            color: white;
            box-shadow: 0 0 8px 4px rgba(255, 50, 50, 0.7);
            border: 2px solid #c0392b; 
        }
        .enemy.dead, .party-member.dead {
            background-color: #c0392b !important;
            opacity: 0.5;
            box-shadow: none !important; 
            z-index: 1 !important; /* Dead characters behind living ones */
        }
        .ui-panel {
            background-color: #4a6178;
            padding: 15px;
            border: 2px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ui-panel h2, .ui-panel h3 {
            color: #f1c40f;
            margin-bottom: 5px;
            text-align: center;
        }
        .stats-container, #enemies-stats-container { 
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom:5px;
        }
        .character-stats, .enemy-stats-block { 
            border: 1px solid #7f8c8d;
            padding: 5px;
            font-size: 0.65rem;
        }
        .character-stats h4, .enemy-stats-block h4 { 
            cursor: pointer;
            text-decoration: underline;
        }
        .character-stats h4:hover, .enemy-stats-block h4:hover {
            color: #f39c12;
        }
        .character-stats.active-char-ui { 
            border-color: #f1c40f;
            background-color: #56708a;
        }
        .character-stats p, .enemy-stats-block p { margin: 2px 0; }

        .health-bar-container {
            margin-top: 3px;
            position: relative; 
        }
        .health-bar {
            width: 100%;
            height: 12px;
            background-color: #c0392b; 
            border: 1px solid #2c3e50;
            border-radius: 3px;
            overflow: hidden; 
        }
        .health-bar-current {
            height: 100%;
            background-color: #2ecc71; 
            width: 100%; 
            transition: width 0.3s ease-out;
            border-radius: 2px 0 0 2px; 
        }
        .health-bar-text {
            position: absolute;
            top: -1px; 
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.55rem;
            color: white; 
            line-height: 14px; 
            text-shadow: 1px 1px 1px #2c3e50; 
        }


        .turn-order-container {
            border: 1px solid #7f8c8d;
            padding: 8px;
            margin-top: 5px;
        }
        .turn-order-toggle {
            cursor: pointer;
            user-select: none;
        }
        .turn-order-toggle:hover {
            color: #f39c12;
        }
        .turn-order-container h3 { font-size: 0.75rem; margin-bottom: 3px;} 
        .turn-order-list { 
            list-style: none; padding: 0; margin: 0; font-size: 0.65rem;
            max-height: 100px; 
            overflow-y: auto;
        }
        .turn-order-list.collapsed {
            display: none;
        }
        .turn-order-list li { padding: 2px 3px; border-bottom: 1px dashed #7f8c8d;} 
        .turn-order-list li:last-child { border-bottom: none; }
        .turn-order-list li.current-turn-visual { 
            background-color: #f1c40f;
            color: #2c3e50;
            font-weight: bold;
        }

        .combat-log {
            height: 100px; 
            overflow-y: auto;
            background-color: #2c3e50;
            border: 1px solid #7f8c8d;
            padding: 8px;
            font-size: 0.6rem;
            line-height: 1.4;
        }
        .combat-log p { margin-bottom: 4px; }
        .combat-log .player-action { color: #3498db; } 
        .combat-log .enemy-action { color: #e74c3c; } 
        .combat-log .info { color: #f1c40f; } 
        .combat-log .banter { color: #e67e22; font-style: italic;} 
        /* .combat-log .hint { color: #1abc9c; font-weight: bold;} Removed hint style */


        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #f1c40f; 
            color: #2c3e50; 
            border: 2px solid #2c3e50;
            padding: 8px 12px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.7rem;
        }
        button:disabled {
            background-color: #7f8c8d; 
            cursor: not-allowed;
            color: #bdc3c7;
        }
        button:hover:not(:disabled) {
            background-color: #f39c12; 
        }
        .selected-action {
            border-color: #e67e22 !important; 
            box-shadow: 0 0 5px #e67e22;
        }
        .map-cell.reachable {
            background-color: #b8c9d4 !important; 
            cursor: pointer;
            outline: 1px dashed #f1c40f;
        }
        .map-cell.reachable:hover {
            background-color: #cad5dd !important;
        }
        .map-cell.attackable-area {
            background-color: #d1c4e9 !important; 
            cursor: crosshair;
            outline: 1px dashed #9b59b6; 
        }
         .map-cell.targetable-enemy {
            outline: 3px dashed #e74c3c !important; 
            cursor: crosshair;
        }
        
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); 
            padding-top: 60px;
        }
        .modal-content {
            background-color: #34495e;
            margin: 5% auto; 
            padding: 20px;
            border: 3px solid #f1c40f;
            width: 80%; 
            max-width: 400px;
            font-size: 0.8rem;
            color: #ecf0f1;
            position: relative;
        }
        .modal-close-button {
            color: #f1c40f;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .modal-close-button:hover,
        .modal-close-button:focus {
            color: #f39c12;
            text-decoration: none;
        }
        .modal-content h3 {
            color: #f1c40f;
            text-align: center;
            margin-bottom: 15px;
        }
        .modal-content p {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div id="start-menu">
        <h1 class="text-2xl">Choose Difficulty</h1>
        <button id="easy-button">Easy (1 Goblin)</button>
        <button id="medium-button">Medium (2 Goblins)</button>
        <button id="hard-button">Hard (1 Boss Goblin, 1 Goblin)</button>
    </div>

    <div class="game-container" id="game-container">
        <div id="map-grid" class="map-grid"></div>
        <div class="ui-panel">
            <div class="turn-order-container">
                <h3 class="turn-order-toggle">Turn Order <span id="turn-order-indicator">[+]</span></h3>
                <ul id="turn-order-list" class="turn-order-list collapsed"></ul>
            </div>
            <div id="party-stats-container" class="stats-container"></div>
            <div id="enemies-stats-container"> 
                <h3>Enemies</h3>
                 </div>
            <div id="action-buttons" class="flex flex-col gap-2">
                <button id="move-button">Move</button>
                <button id="attack-button">Attack</button>
                <button id="end-turn-button">End Turn</button>
            </div>
            <h3>Combat Log</h3>
            <div id="combat-log" class="combat-log">
                <p class="info">Select a difficulty to start.</p>
            </div>
        </div>
    </div>

    <div id="stats-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close-button">&times;</span>
            <h3 id="modal-char-name">Character Name</h3>
            <p>HP: <span id="modal-char-hp"></span>/<span id="modal-char-maxhp"></span></p>
            <p>AC: <span id="modal-char-ac"></span></p>
            <p>Speed: <span id="modal-char-speed"></span> squares</p>
            <p>Attack: <span id="modal-char-attackname"></span></p>
            <p>Attack Bonus: +<span id="modal-char-atkbonus"></span></p>
            <p>Damage: 1d<span id="modal-char-dmgdice"></span> + <span id="modal-char-dmgbonus"></span></p>
            <p>Dexterity Mod: <span id="modal-char-dexmod"></span></p>
        </div>
    </div>

    <script>
        const GRID_SIZE = 12;
        const CELL_SIZE = 30;
        const OBSTACLE_CHANCE = 0.15; 

        const initialMapLayout = [ 
            "............", ".#........G.", ".#....####..", "......#.....",
            "....#.......", "....#...#...", "..###...#...", "........#...",
            ".####...#...", "..M.......#.", "..R.......#.", "............"
        ];
        
        let currentMapState = []; 
        let enemies = []; 

        const party = [
            {
                id: "mage", name: "Mage", char: "M", hp: 15, maxHp: 15, ac: 12, 
                attackName: "Fire Bolt (Ranged)", attackBonus: 4, damageDice: 10, damageBonus: 2, 
                speed: 3, x: 0, y: 0, dexMod: 1, initiative: 0, isDead: false, element: null, 
                hasMovedThisTurn: false, hasActedThisTurn: false, isRangedAttacker: true, attackRange: 6 
            },
            {
                id: "rogue", name: "Rogue", char: "R", hp: 18, maxHp: 18, ac: 14, 
                attackName: "Shortsword (Melee)", attackBonus: 5, damageDice: 6, damageBonus: 3, 
                speed: 3, x: 0, y: 0, dexMod: 3, initiative: 0, isDead: false, element: null, 
                hasMovedThisTurn: false, hasActedThisTurn: false, isRangedAttacker: false, attackRange: 1
            }
        ];

        let turnOrder = [];
        let currentTurnIndex = 0;
        let selectedAction = null; 
        let gameEnded = false;

        const startMenu = document.getElementById('start-menu');
        const gameContainer = document.getElementById('game-container');
        const mapGrid = document.getElementById('map-grid');
        const partyStatsContainer = document.getElementById('party-stats-container');
        const enemiesStatsContainer = document.getElementById('enemies-stats-container'); 
        const combatLog = document.getElementById('combat-log');
        const moveButton = document.getElementById('move-button');
        const attackButton = document.getElementById('attack-button');
        // const tacticalHintButton = document.getElementById('tactical-hint-button'); // Removed
        const endTurnButton = document.getElementById('end-turn-button');
        const turnOrderListUI = document.getElementById('turn-order-list');
        const turnOrderToggle = document.querySelector('.turn-order-toggle');
        const turnOrderIndicator = document.getElementById('turn-order-indicator');
        const statsModal = document.getElementById('stats-modal');
        const modalCloseButton = document.querySelector('.modal-close-button');

        const GEMINI_API_KEY = ""; 
        const GEMINI_API_URL_TEXT = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`;

        async function callGemini(promptText) { 
            const payload = { contents: [{ role: "user", parts: [{ text: promptText }] }] };
            try {
                const response = await fetch(GEMINI_API_URL_TEXT, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.text(); console.error("Gemini API Error Response:", errorBody); throw new Error(`Gemini API request failed with status ${response.status}`); }
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text.trim();
                } else { console.error("Gemini API - Unexpected response structure:", result); return "The spirits are silent..."; }
            } catch (error) { console.error("Error calling Gemini API:", error); return "The connection to the ethereal plane is unstable..."; }
        }
        function rollDice(sides) { return Math.floor(Math.random() * sides) + 1; }
        function addToLog(message, type = 'info') { 
            const logEntry = document.createElement('p');
            logEntry.textContent = message;
            logEntry.classList.add(type);
            combatLog.appendChild(logEntry);
            combatLog.scrollTop = combatLog.scrollHeight; 
        }
        function updateHPDisplays() {
            party.forEach(member => {
                const hpTextSpan = document.getElementById(`hp-text-${member.id}`);
                const hpBarDiv = document.getElementById(`hp-bar-${member.id}`);
                if (hpTextSpan && hpBarDiv) {
                    hpTextSpan.textContent = member.hp;
                    const percentage = (member.hp / member.maxHp) * 100;
                    hpBarDiv.style.width = `${Math.max(0, percentage)}%`;
                }
            });
            enemies.forEach(enemy => {
                const hpTextSpan = document.getElementById(`hp-text-enemy-${enemy.uniqueId}`);
                const hpBarDiv = document.getElementById(`hp-bar-enemy-${enemy.uniqueId}`);
                if (hpTextSpan && hpBarDiv) {
                    hpTextSpan.textContent = enemy.hp;
                    const percentage = (enemy.hp / enemy.maxHp) * 100;
                    hpBarDiv.style.width = `${Math.max(0, percentage)}%`;
                }
            });
        }
        function getCell(x, y) { 
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || !mapGrid.children[y * GRID_SIZE + x]) return null;
            return mapGrid.children[y * GRID_SIZE + x];
        }
        function isObstacle(x, y) { 
             if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return true; 
            return currentMapState[y][x] === '#';
        }
        function hasLineOfSight(x0, y0, x1, y1) { 
            let dx = Math.abs(x1 - x0); let dy = Math.abs(y1 - y0);
            let sx = (x0 < x1) ? 1 : -1; let sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            let currentX = x0; let currentY = y0;
            while(true) {
                if (currentX === x1 && currentY === y1) break; 
                let isStartCell = (currentX === x0 && currentY === y0);
                if (!isStartCell && isObstacle(currentX, currentY)) return false; 
                let e2 = 2 * err;
                if (e2 > -dy) { err -= dy; currentX += sx; }
                if (e2 < dx) { err += dx; currentY += sy; }
            }
            return true;
        }
        function heuristic(x1, y1, x2, y2) { return Math.abs(x1 - x2) + Math.abs(y1 - y2); }
        
        function isCellOccupied(x, y, excludeEntity = null) {
            if (party.some(p => (!excludeEntity || !excludeEntity.id || p.id !== excludeEntity.id) && !p.isDead && p.x === x && p.y === y)) return true;
            if (enemies.some(e => (!excludeEntity || excludeEntity.id || e.uniqueId !== excludeEntity.uniqueId) && !e.isDead && e.x === x && e.y === y)) return true; 
            return false;
        }

       function findPath(startX, startY, endX, endY, movingEntity) {
            let openSet = [{x: startX, y: startY, g: 0, h: heuristic(startX, startY, endX, endY), f: heuristic(startX, startY, endX, endY), parent: null}];
            let closedSet = new Set();

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                let current = openSet.shift();

                if (current.x === endX && current.y === endY) {
                    let pathNodes = []; let temp = current;
                    while (temp) { pathNodes.unshift({x: temp.x, y: temp.y, g: temp.g}); temp = temp.parent; }
                    return { path: pathNodes, cost: current.g };
                }
                closedSet.add(`${current.x},${current.y}`);

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;

                        const isDiagonalMove = (dx !== 0 && dy !== 0);
                        const baseMoveCost = isDiagonalMove ? 2 : 1;

                        const nextX = current.x + dx;
                        const nextY = current.y + dy;

                        if (nextX >= 0 && nextX < GRID_SIZE && nextY >= 0 && nextY < GRID_SIZE && !isObstacle(nextX, nextY) && !closedSet.has(`${nextX},${nextY}`)) {
                            if (!isCellOccupied(nextX, nextY, movingEntity) || (nextX === endX && nextY === endY)) {
                                let gScore = current.g + baseMoveCost;
                                let existingNeighbor = openSet.find(n => n.x === nextX && n.y === nextY);
                                if (!existingNeighbor || gScore < existingNeighbor.g) {
                                    let hScore = heuristic(nextX, nextY, endX, endY);
                                    if (existingNeighbor) {
                                        existingNeighbor.g = gScore; existingNeighbor.f = gScore + hScore; existingNeighbor.parent = current;
                                    } else {
                                        openSet.push({x: nextX, y: nextY, g: gScore, h: hScore, f: gScore + hScore, parent: current});
                                    }
                                }
                            }
                        }

                        if (dx === 0 || dy === 0 || Math.abs(dx) === Math.abs(dy)) { 
                            const jumpOverX = current.x + dx; 
                            const jumpOverY = current.y + dy;
                            const landX = current.x + 2 * dx; 
                            const landY = current.y + 2 * dy;

                            if (jumpOverX >= 0 && jumpOverX < GRID_SIZE && jumpOverY >= 0 && jumpOverY < GRID_SIZE && !isObstacle(jumpOverX, jumpOverY) &&
                                landX >= 0 && landX < GRID_SIZE && landY >= 0 && landY < GRID_SIZE && !isObstacle(landX, landY) && !closedSet.has(`${landX},${landY}`)) {
                                
                                const jumpedChar = party.find(p=>p.x === jumpOverX && p.y === jumpOverY && !p.isDead && p !== movingEntity) || 
                                                 enemies.find(e=>e.x === jumpOverX && e.y === jumpOverY && !e.isDead && e !== movingEntity);

                                const canLand = !isCellOccupied(landX, landY, movingEntity) || (landX === endX && landY === endY);

                                if (jumpedChar && canLand) { 
                                    let gScore = current.g + (baseMoveCost * 2); 
                                    
                                    let existingNeighbor = openSet.find(n => n.x === landX && n.y === landY);
                                    if (!existingNeighbor || gScore < existingNeighbor.g) {
                                        let hScore = heuristic(landX, landY, endX, endY);
                                        if (existingNeighbor) {
                                            existingNeighbor.g = gScore; existingNeighbor.f = gScore + hScore; existingNeighbor.parent = current;
                                        } else {
                                            openSet.push({x: landX, y: landY, g: gScore, h: hScore, f: gScore + hScore, parent: current});
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }


        function initializeCurrentMapState() { /* ... (same as before) ... */ 
            currentMapState = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                currentMapState[r] = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    currentMapState[r][c] = (initialMapLayout[r][c] === '#') ? '#' : '.';
                }
            }
        }
        function generateAdditionalRandomObstacles() { /* ... (same as before) ... */ 
            let entityPositions = [];
            party.forEach(p => entityPositions.push({x: p.x, y: p.y}));
            enemies.forEach(e => entityPositions.push({x: e.x, y: e.y})); 
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const isEntityPos = entityPositions.some(pos => pos.x === c && pos.y === r);
                    if (currentMapState[r][c] === '.' && !isEntityPos) { 
                        if (Math.random() < OBSTACLE_CHANCE) currentMapState[r][c] = '#';
                    }
                }
            }
        }
        function drawMapFromState() { /* ... (same as before) ... */ 
            mapGrid.innerHTML = ''; 
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('map-cell');
                    cell.dataset.col = c; cell.dataset.row = r;
                    if (currentMapState[r][c] === '#') {
                        cell.classList.add('obstacle'); cell.textContent = '🪨';
                    }
                    cell.addEventListener('click', () => handleCellClick(parseInt(cell.dataset.col), parseInt(cell.dataset.row)));
                    mapGrid.appendChild(cell);
                }
            }
        }
        
        function createEntityElement(entity) { 
            const elem = document.createElement('div');
            if (entity.id) { 
                elem.classList.add(entity.id); 
                elem.classList.add('party-member');
            } else { 
                if (entity.name.toLowerCase().includes("boss")) {
                    elem.classList.add('boss-goblin-enemy');
                } else {
                    elem.classList.add('goblin-enemy');
                }
                elem.classList.add('enemy');
            }
            elem.textContent = entity.char;
            entity.element = elem; 
            mapGrid.appendChild(entity.element); 
            positionEntity(entity); 
        }

        function positionEntity(entity) { /* ... (same as before) ... */ 
            if (entity.element) {
                entity.element.style.left = `${entity.x * CELL_SIZE + (CELL_SIZE - 26)/2}px`;
                entity.element.style.top = `${entity.y * CELL_SIZE + (CELL_SIZE - 26)/2}px`;
                entity.element.classList.remove('active-sprite'); 
                const currentActor = turnOrder[currentTurnIndex];
                if (currentActor && ((entity.id && entity.id === currentActor.id) || (!entity.id && entity.name === currentActor.name && entity.uniqueId === currentActor.uniqueId)) && !entity.isDead) { 
                    entity.element.classList.add('active-sprite');
                }
            }
            const cells = mapGrid.children;
            for (let i = 0; i < cells.length; i++) { 
                cells[i].classList.remove('active-character-cell-map');
            }
            const currentActor = turnOrder[currentTurnIndex];
            if (currentActor && !currentActor.isDead) { 
                const charCell = getCell(currentActor.x, currentActor.y);
                if (charCell) charCell.classList.add('active-character-cell-map');
            }
        }
        
        function renderPartyStats() { 
            partyStatsContainer.innerHTML = '<h3>Party</h3>'; 
            party.forEach((member) => { 
                const statsDiv = document.createElement('div');
                statsDiv.classList.add('character-stats');
                statsDiv.id = `stats-${member.id}`;
                const currentActor = turnOrder[currentTurnIndex];
                if (currentActor && currentActor.id === member.id && !member.isDead) {
                    statsDiv.classList.add('active-char-ui');
                }
                statsDiv.innerHTML = `
                    <h4 data-entityid="${member.id}">${member.name} (${member.char}) ${member.isDead ? "[DEAD]" : ""}</h4>
                    <div class="health-bar-container">
                        <div class="health-bar">
                            <div id="hp-bar-${member.id}" class="health-bar-current" style="width: ${ (member.hp / member.maxHp) * 100 }%;"></div>
                        </div>
                        <div class="health-bar-text">HP: <span id="hp-text-${member.id}">${member.hp}</span>/${member.maxHp}</div>
                    </div>
                    <p>AC: ${member.ac}</p>
                `;
                partyStatsContainer.appendChild(statsDiv);
                statsDiv.querySelector('h4').addEventListener('click', () => showStatsModal(member));
            });
        }

        function renderEnemyStats() {
            enemiesStatsContainer.innerHTML = '<h3>Enemies</h3>'; 
            enemies.forEach(enemy => {
                if (!enemy.isDead) {
                    const statsDiv = document.createElement('div');
                    statsDiv.classList.add('enemy-stats-block'); 
                    statsDiv.id = `stats-enemy-${enemy.uniqueId}`;
                     const currentActor = turnOrder[currentTurnIndex];
                    if (currentActor && !currentActor.id && currentActor.uniqueId === enemy.uniqueId) { 
                        statsDiv.classList.add('active-char-ui'); 
                    }
                    statsDiv.innerHTML = `
                        <h4 data-enemyid="${enemy.uniqueId}">${enemy.name} (${enemy.char})</h4>
                        <div class="health-bar-container">
                            <div class="health-bar">
                                <div id="hp-bar-enemy-${enemy.uniqueId}" class="health-bar-current" style="width: ${ (enemy.hp / enemy.maxHp) * 100 }%;"></div>
                            </div>
                            <div class="health-bar-text">HP: <span id="hp-text-enemy-${enemy.uniqueId}">${enemy.hp}</span>/${enemy.maxHp}</div>
                        </div>
                        <p>AC: ${enemy.ac}</p>
                    `;
                    enemiesStatsContainer.appendChild(statsDiv);
                    statsDiv.querySelector('h4').addEventListener('click', () => showStatsModal(enemy));
                }
            });
        }


        function highlightCells() { /* ... (same as before) ... */ 
            const cells = mapGrid.children;
            for (let i = 0; i < cells.length; i++) {
                cells[i].classList.remove('reachable', 'targetable-enemy', 'attackable-area');
            }
            const currentActor = turnOrder[currentTurnIndex];
            if (currentActor) positionEntity(currentActor); 
            if (!currentActor || currentActor.isDead || !currentActor.id) return; 
            if (selectedAction === 'move' && !currentActor.hasMovedThisTurn) {
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (isCellOccupied(c, r, currentActor) || isObstacle(c,r)) continue; 
                        let pathResult = findPath(currentActor.x, currentActor.y, c, r, currentActor); 
                        if (pathResult && pathResult.cost <= currentActor.speed && pathResult.path.length > 1) {
                             getCell(c,r)?.classList.add('reachable');
                        }
                    }
                }
            } else if (selectedAction === 'attack' && !currentActor.hasActedThisTurn) {
                for (let r = 0; r < GRID_SIZE; r++) { 
                    for (let c = 0; c < GRID_SIZE; c++) {
                        if (isObstacle(c,r) && !(enemies.some(e => e.x === c && e.y === r))) continue; 
                        const distToCell = Math.max(Math.abs(currentActor.x - c), Math.abs(currentActor.y - r));
                        let cellIsAttackable = false;
                        if (currentActor.isRangedAttacker) {
                            cellIsAttackable = distToCell <= currentActor.attackRange && hasLineOfSight(currentActor.x, currentActor.y, c, r);
                        } else { 
                            cellIsAttackable = distToCell === 1; 
                        }
                        if (cellIsAttackable) {
                            getCell(c,r)?.classList.add('attackable-area');
                        }
                    }
                }
                enemies.forEach(enemy => { 
                    if (!enemy.isDead) {
                        const enemyCell = getCell(enemy.x, enemy.y);
                        if(enemyCell && enemyCell.classList.contains('attackable-area')){
                            enemyCell.classList.add('targetable-enemy');
                        }
                    }
                });
            }
        }

        function clearHighlightsAndSelection() { 
            selectedAction = null;
            highlightCells(); 
            updateActionButtonsState();
        }

        function updateActionButtonsState() { /* ... (same as before) ... */
            const currentActor = turnOrder[currentTurnIndex];
            if (!currentActor || currentActor.isDead || !currentActor.id || gameEnded) { 
                moveButton.disabled = true;
                attackButton.disabled = true;
                // tacticalHintButton.disabled = true; // Removed
                moveButton.classList.remove('selected-action');
                attackButton.classList.remove('selected-action');
            } else { 
                moveButton.disabled = currentActor.hasMovedThisTurn;
                attackButton.disabled = currentActor.hasActedThisTurn;
                // tacticalHintButton.disabled = false; // Removed

                if(selectedAction === 'move' && !moveButton.disabled) moveButton.classList.add('selected-action');
                else moveButton.classList.remove('selected-action');
                
                if(selectedAction === 'attack' && !attackButton.disabled) attackButton.classList.add('selected-action');
                else attackButton.classList.remove('selected-action');
            }
            endTurnButton.disabled = gameEnded;
        }
        
        function handleCellClick(col, row) { 
            const currentActor = turnOrder[currentTurnIndex];
            if (gameEnded || !currentActor ) return; 

            if (!selectedAction) {
                const clickedEnemy = enemies.find(e => !e.isDead && e.x === col && e.y === row);
                if (clickedEnemy) {
                    showStatsModal(clickedEnemy);
                    return;
                }
                 const clickedPartyMember = party.find(p => !p.isDead && p.x === col && p.y === row && (!currentActor.id || p.id !== currentActor.id)); 
                if(clickedPartyMember){
                    showStatsModal(clickedPartyMember);
                    return;
                }
            }
            
            if (!currentActor.id || currentActor.isDead || !selectedAction) return; 

            if (selectedAction === 'move' && !currentActor.hasMovedThisTurn) {
                if (getCell(col,row)?.classList.contains('reachable')) {
                    currentActor.x = col;
                    currentActor.y = row;
                    addToLog(`${currentActor.name} moves to (${col}, ${row}).`, 'player-action');
                    currentActor.hasMovedThisTurn = true;
                    clearHighlightsAndSelection();
                } else {
                    addToLog("Cannot move there or invalid target.", 'info');
                }
            } else if (selectedAction === 'attack' && !currentActor.hasActedThisTurn) {
                const targetEnemy = enemies.find(e => !e.isDead && e.x === col && e.y === row);
                if (targetEnemy && getCell(col,row)?.classList.contains('targetable-enemy')) {
                    handlePlayerAttack(currentActor, targetEnemy);
                } else {
                    addToLog("Click on a highlighted Enemy to attack.", 'info');
                }
            }
        }
        
        async function handlePlayerAttack(attacker, target) { /* ... (same as before) ... */ 
            if (target.isDead) { clearHighlightsAndSelection(); return; }
            const distToTarget = Math.max(Math.abs(attacker.x - target.x), Math.abs(attacker.y - target.y));
            let inRange = false; let attackType = attacker.attackName; let isRangedForDisadvantageCheck = attacker.isRangedAttacker;
            if (attacker.isRangedAttacker) {
                inRange = distToTarget <= attacker.attackRange && hasLineOfSight(attacker.x, attacker.y, target.x, target.y);
            } else { inRange = distToTarget === 1; }
            if (!inRange) { addToLog(`${attacker.name} target: ${target.name} is not in attack range or sight.`, 'info'); clearHighlightsAndSelection(); return; }
            let disadvantage = isRangedForDisadvantageCheck && (distToTarget <=1 && !target.isDead);
            const roll1 = rollDice(20); let attackRollValue = roll1;
            let logMessage = `${attacker.name} attacks ${target.name} with ${attackType}. Roll: ${roll1}`;
            if (disadvantage) { const roll2 = rollDice(20); attackRollValue = Math.min(roll1, roll2); logMessage += ` (Disadvantage: rolled ${roll1}, ${roll2} -> using ${attackRollValue})`; }
            const finalAttackRoll = attackRollValue + attacker.attackBonus; logMessage += ` + ${attacker.attackBonus} = ${finalAttackRoll}.`;
            if (finalAttackRoll >= target.ac || attackRollValue === 20) {
                let damage = rollDice(attacker.damageDice) + attacker.damageBonus;
                if (attackRollValue === 20) { damage += rollDice(attacker.damageDice); logMessage += " CRITICAL HIT!"; }
                target.hp = Math.max(0, target.hp - damage); logMessage += ` Hit! ${target.name} takes ${damage} damage.`; updateHPDisplays(); renderEnemyStats();
                if (target.hp === 0) {
                    target.isDead = true; target.element.classList.add('dead'); target.element.textContent = 'X';
                    logMessage += ` ${target.name} defeated!`; 
                    if (enemies.every(e => e.isDead)) {
                        addToLog(logMessage, 'player-action'); endGame(true); return;
                    }
                }
            } else { logMessage += " Miss!"; }
            if (!gameEnded) addToLog(logMessage, 'player-action');
            attacker.hasActedThisTurn = true; clearHighlightsAndSelection();
        }

        async function enemyAct(enemy) { 
             if (enemy.isDead || party.every(p => p.isDead) || gameEnded) {
                 if (!gameEnded) startNextTurn(); 
                 return;
             }
            addToLog(`${enemy.name}'s turn.`, 'enemy-action'); let enemyActedThisTurn = false;
            let closestMember = null; let minDist = Infinity;
            party.forEach(member => {
                if (!member.isDead) {
                    const dist = heuristic(enemy.x, enemy.y, member.x, member.y); 
                    if (dist < minDist) { minDist = dist; closestMember = member; } 
                    else if (dist === minDist && Math.random() < 0.5) { closestMember = member; }
                }
            });
            if (!closestMember) { if (!gameEnded) startNextTurn(); return; }
            const actualDistToTarget = Math.max(Math.abs(closestMember.x - enemy.x), Math.abs(closestMember.y - enemy.y));
            if (actualDistToTarget === 1) { // Attack
                const attackRoll = rollDice(20); const finalAttackRoll = attackRoll + enemy.attackBonus;
                let logMessage = `${enemy.name} attacks ${closestMember.name} with ${enemy.attackName}. Roll: ${attackRoll} + ${enemy.attackBonus} = ${finalAttackRoll}.`;
                 if (finalAttackRoll >= closestMember.ac || attackRoll === 20) { 
                    let damage = rollDice(enemy.damageDice) + enemy.damageBonus;
                    if (attackRoll === 20) { damage += rollDice(enemy.damageDice); logMessage += " CRITICAL HIT!";}
                    closestMember.hp = Math.max(0, closestMember.hp - damage);
                    logMessage += ` Hit! ${closestMember.name} takes ${damage} damage.`;
                    updateHPDisplays(); renderPartyStats();
                    if (closestMember.hp === 0) { 
                        closestMember.isDead = true; closestMember.element.classList.add('dead'); closestMember.element.textContent = 'X';
                        logMessage += ` ${closestMember.name} defeated!`;
                        if (party.every(p => p.isDead)) { addToLog(logMessage, 'enemy-action'); endGame(false); return;}
                    }
                    const banterPrompt = `You are a ${enemy.name} in a D&D game. You just hit a ${closestMember.name}. Say a short, menacing or funny taunt (1-2 sentences, max 15 words).`;
                    const banter = await callGemini(banterPrompt); addToLog(`${enemy.name}: "${banter}"`, 'banter');
                 } else { logMessage += " Miss!"; }
                 addToLog(logMessage, 'enemy-action'); enemyActedThisTurn = true;
            } else { // Move
                 let pathResult = findPath(enemy.x, enemy.y, closestMember.x, closestMember.y, enemy); 
                 let moved = false;
                 if (pathResult && pathResult.path.length > 1) {
                    let path = pathResult.path; let bestLandingX = enemy.x; let bestLandingY = enemy.y;
                    for (let i = 1; i < path.length; i++) {
                        const step = path[i]; if (step.g > enemy.speed) break; 
                        if (step.x === closestMember.x && step.y === closestMember.y) {
                            if (i > 0 && !isCellOccupied(path[i-1].x, path[i-1].y, enemy)) {
                                bestLandingX = path[i-1].x; bestLandingY = path[i-1].y;
                            } break; 
                        }
                        if (!isCellOccupied(step.x, step.y, enemy)) {
                            bestLandingX = step.x; bestLandingY = step.y;
                        }
                        if (heuristic(bestLandingX, bestLandingY, closestMember.x, closestMember.y) === 1) break; 
                    }
                    if (bestLandingX !== enemy.x || bestLandingY !== enemy.y) {
                        enemy.x = bestLandingX; enemy.y = bestLandingY; positionEntity(enemy);
                        addToLog(`${enemy.name} moves to (${enemy.x}, ${enemy.y}).`, 'enemy-action'); enemyActedThisTurn = true;
                        if (Math.max(Math.abs(closestMember.x - enemy.x), Math.abs(closestMember.y - enemy.y)) === 1 && !closestMember.isDead) {
                            const attackRoll = rollDice(20); const finalAttackRoll = attackRoll + enemy.attackBonus;
                            let logMessage = `${enemy.name} attacks ${closestMember.name} with ${enemy.attackName}. Roll: ${attackRoll} + ${enemy.attackBonus} = ${finalAttackRoll}.`;
                             if (finalAttackRoll >= closestMember.ac || attackRoll === 20) { 
                                let damage = rollDice(enemy.damageDice) + enemy.damageBonus;
                                if (attackRoll === 20) { damage += rollDice(enemy.damageDice); logMessage += " CRITICAL HIT!"; }
                                closestMember.hp = Math.max(0, closestMember.hp - damage);
                                logMessage += ` Hit! ${closestMember.name} takes ${damage} damage.`;
                                updateHPDisplays(); renderPartyStats();
                                if (closestMember.hp === 0) { 
                                    closestMember.isDead = true; closestMember.element.classList.add('dead'); closestMember.element.textContent = 'X';
                                    logMessage += ` ${closestMember.name} defeated!`;
                                    if (party.every(p => p.isDead)) { addToLog(logMessage, 'enemy-action'); endGame(false); return;}
                                }
                                 const banterPrompt = `You are a ${enemy.name} in a D&D game. You just hit a ${closestMember.name}. Say a short, menacing or funny taunt (1-2 sentences, max 15 words).`;
                                 const banter = await callGemini(banterPrompt); addToLog(`${enemy.name}: "${banter}"`, 'banter');
                             } else { logMessage += " Miss!"; }
                             addToLog(logMessage, 'enemy-action');
                        }
                    }
                 }
                 if (!enemyActedThisTurn && actualDistToTarget > 1) { 
                     addToLog(`${enemy.name} is blocked or has nowhere to move closer.`, 'enemy-action'); enemyActedThisTurn = true;
                 }
            }
            if (!enemyActedThisTurn && !gameEnded) { addToLog(`${enemy.name} does nothing.`, 'enemy-action'); }
            if (!gameEnded) startNextTurn();
        }

        function endGame(playerWon) { /* ... (same as before) ... */ 
            gameEnded = true;
            clearHighlightsAndSelection();
            if (playerWon) {
                addToLog("Victory! Your party defeated the enemies!", 'info');
            } else {
                addToLog("Defeat! The enemies bested your party.", 'info');
            }
        }
        
        function rollInitiative() {
            turnOrder = [];
            party.forEach(p => {
                if (!p.isDead) {
                    p.initiative = rollDice(20) + p.dexMod;
                    turnOrder.push(p);
                }
            });
            enemies.forEach(e => { 
                if (!e.isDead) {
                    e.initiative = rollDice(20) + e.dexMod;
                    turnOrder.push(e);
                }
            });
            turnOrder.sort((a,b) => b.initiative - a.initiative); 
            currentTurnIndex = -1; 
            displayTurnOrder();
        }

        function displayTurnOrder() {
            turnOrderListUI.innerHTML = '';
            turnOrder.forEach((entity, index) => {
                if (entity.isDead) return; 
                const li = document.createElement('li');
                li.textContent = `${entity.name} (Init: ${entity.initiative})`;
                if (index === currentTurnIndex) {
                    li.classList.add('current-turn-visual');
                }
                turnOrderListUI.appendChild(li);
            });
        }

        function startNextTurn() {
            if (gameEnded) return;
            const previousActor = turnOrder[currentTurnIndex];
            if (previousActor && previousActor.element) {
                previousActor.element.classList.remove('active-sprite');
            }
            if (previousActor && previousActor.id){ 
                 const prevStatsUI = document.getElementById(`stats-${previousActor.id}`);
                 if(prevStatsUI) prevStatsUI.classList.remove('active-char-ui');
            }
            if (previousActor && !previousActor.id) {
                const prevEnemyStatsUI = document.getElementById(`stats-enemy-${previousActor.uniqueId}`);
                if (prevEnemyStatsUI) prevEnemyStatsUI.classList.remove('active-char-ui');
            }

            let nextTurnFound = false;
            for (let i = 0; i < turnOrder.length; i++) {
                currentTurnIndex = (currentTurnIndex + 1) % turnOrder.length;
                if (!turnOrder[currentTurnIndex].isDead) {
                    nextTurnFound = true;
                    break;
                }
            }
            if (!nextTurnFound) { 
                 if (enemies.every(e => e.isDead)) endGame(true); 
                 else if (party.every(p => p.isDead)) endGame(false); 
                 return;
            }

            const currentActor = turnOrder[currentTurnIndex];
            addToLog(`${currentActor.name}'s turn.`, 'info');
            selectedAction = null;

            if (currentActor.id) { 
                currentActor.hasMovedThisTurn = false;
                currentActor.hasActedThisTurn = false;
                renderPartyStats(); 
                renderEnemyStats(); 
            } else { 
                renderPartyStats(); 
                renderEnemyStats(); 
            }
            
            positionEntity(currentActor); 
            displayTurnOrder();
            updateActionButtonsState();
            highlightCells();

            if (!currentActor.id && !currentActor.isDead) { 
                setTimeout(() => enemyAct(currentActor), 500); 
            }
        }
        
        function showStatsModal(entity) { 
            document.getElementById('modal-char-name').textContent = entity.name;
            document.getElementById('modal-char-hp').textContent = entity.hp;
            document.getElementById('modal-char-maxhp').textContent = entity.maxHp;
            document.getElementById('modal-char-ac').textContent = entity.ac;
            document.getElementById('modal-char-speed').textContent = entity.speed;
            document.getElementById('modal-char-attackname').textContent = entity.attackName;
            document.getElementById('modal-char-atkbonus').textContent = entity.attackBonus;
            document.getElementById('modal-char-dmgdice').textContent = entity.damageDice;
            document.getElementById('modal-char-dmgbonus').textContent = entity.damageBonus;
            document.getElementById('modal-char-dexmod').textContent = entity.dexMod;
            statsModal.style.display = "block";
        }
        function hideStatsModal() { statsModal.style.display = "none"; }

        function setupEnemies(difficulty) {
            enemies = []; 
            document.querySelectorAll('.enemy').forEach(el => el.remove());
            let idCounter = 0; 

            let goblinBase = {
                name: "Goblin", char: "G", hp: 7, maxHp: 7, ac: 15, 
                attackName: "Scimitar (Melee)", attackBonus: 4, damageDice: 6, damageBonus: 2,
                speed: 3, dexMod: 2, initiative: 0, isDead: false, element: null
            };

            if (difficulty === 'easy') {
                enemies.push({...goblinBase, name: "Goblin", x: 10, y: 1, uniqueId: `goblin-${idCounter++}`});
            } else if (difficulty === 'medium') {
                enemies.push({...goblinBase, name: "Goblin Alpha", x: 10, y: 1, uniqueId: `goblin-${idCounter++}`});
                enemies.push({...goblinBase, name: "Goblin Beta", x: 9, y: 2, uniqueId: `goblin-${idCounter++}`});
            } else if (difficulty === 'hard') {
                enemies.push({
                    name: "Boss Goblin", char: "B", hp: 20, maxHp: 20, ac: 16, 
                    attackName: "Heavy Scimitar", attackBonus: 5, damageDice: 8, damageBonus: 3,
                    speed: 3, x: 10, y: 1, dexMod: 1, initiative: 0, isDead: false, element: null, uniqueId: `boss-${idCounter++}`
                });
                enemies.push({...goblinBase, name: "Goblin Guard", x: 9, y: 2, uniqueId: `goblin-${idCounter++}`});
            }
            enemies.forEach(e => createEntityElement(e));
            renderEnemyStats(); 
            updateHPDisplays(); 
        }

        // Tactical Hint function removed as per user request in previous turn.
        // async function getTacticalHint() { /* ... */ }


        function initializeGame(difficulty) {
            startMenu.style.display = 'none';
            gameContainer.style.display = 'grid';
            combatLog.innerHTML = '<p class="info">Game started. Rolling initiative...</p>'; 

            gameEnded = false; 
            party.forEach(p => { 
                p.hp = p.maxHp;
                p.isDead = false;
                p.hasMovedThisTurn = false;
                p.hasActedThisTurn = false;
                for(let r=0; r < GRID_SIZE; r++) { 
                    for(let c=0; c < GRID_SIZE; c++) {
                        if (initialMapLayout[r][c] === p.char) { p.x = c; p.y = r; }
                    }
                }
            });

            setupEnemies(difficulty);
            
            initializeCurrentMapState(); 
            generateAdditionalRandomObstacles(); 
            drawMapFromState(); 

            party.forEach(member => { 
                if(member.element) member.element.remove(); 
                createEntityElement(member); 
            }); 
            enemies.forEach(enemy => {
                if(enemy.element) enemy.element.remove(); 
                createEntityElement(enemy);
            });
            
            renderPartyStats(); 
            renderEnemyStats();
            updateHPDisplays();
            rollInitiative();
            startNextTurn(); 
        }

        function gameSetup() {
            mapGrid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
            mapGrid.style.gridTemplateRows = `repeat(${GRID_SIZE}, ${CELL_SIZE}px)`;
            mapGrid.style.width = `${GRID_SIZE * CELL_SIZE}px`;
            mapGrid.style.height = `${GRID_SIZE * CELL_SIZE}px`;
            
            document.getElementById('easy-button').addEventListener('click', () => initializeGame('easy'));
            document.getElementById('medium-button').addEventListener('click', () => initializeGame('medium'));
            document.getElementById('hard-button').addEventListener('click', () => initializeGame('hard'));

            moveButton.addEventListener('click', () => {
                const currentActor = turnOrder[currentTurnIndex];
                if (!currentActor || !currentActor.id || gameEnded || currentActor.hasMovedThisTurn || currentActor.isDead) return;
                selectedAction = (selectedAction === 'move' ? null : 'move');
                updateActionButtonsState(); highlightCells();
                if(selectedAction === 'move') addToLog(`${currentActor.name}: Select a square to move to.`, 'info');
                else if (selectedAction === null) addToLog(`${currentActor.name}: Move action deselected.`, 'info');
            });
            attackButton.addEventListener('click', () => {
                const currentActor = turnOrder[currentTurnIndex];
                if (!currentActor || !currentActor.id || gameEnded || currentActor.hasActedThisTurn || currentActor.isDead) return;
                 selectedAction = (selectedAction === 'attack' ? null : 'attack');
                updateActionButtonsState(); highlightCells();
                if(selectedAction === 'attack') addToLog(`${currentActor.name}: Select an enemy to attack.`, 'info');
                else if (selectedAction === null) addToLog(`${currentActor.name}: Attack action deselected.`, 'info');
            });
            // tacticalHintButton.addEventListener('click', getTacticalHint); // Removed
            endTurnButton.addEventListener('click', () => {
                const currentActor = turnOrder[currentTurnIndex];
                if (!currentActor || gameEnded || currentActor.isDead) return;
                if (currentActor.id) { 
                     addToLog(`${currentActor.name} ends their turn.`, 'player-action');
                }
                clearHighlightsAndSelection(); 
                startNextTurn(); 
            });
            modalCloseButton.onclick = hideStatsModal;
            window.onclick = function(event) { 
                if (event.target == statsModal) hideStatsModal();
            }
            turnOrderToggle.addEventListener('click', () => {
                turnOrderListUI.classList.toggle('collapsed');
                turnOrderIndicator.textContent = turnOrderListUI.classList.contains('collapsed') ? '[+]' : '[-]';
            });
        }
        gameSetup(); 
    </script>
</body>
</html>
